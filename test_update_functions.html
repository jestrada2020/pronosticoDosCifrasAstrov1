<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test - Correcci√≥n de Funciones Update</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .success { color: #4CAF50; font-weight: bold; }
        .error { color: #f44336; font-weight: bold; }
        .warning { color: #ff9800; font-weight: bold; }
        .test-box {
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        .button {
            background-color: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        .button:hover {
            background-color: #005a87;
        }
        pre {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Test - Correcci√≥n de Funciones Update</h1>
        <p>Este test verifica que todas las funciones de actualizaci√≥n (updateXGBoostResults, etc.) est√©n disponibles y funcionen correctamente.</p>
        
        <button class="button" onclick="testUpdateFunctions()">üß™ Test Funciones Update</button>
        <button class="button" onclick="testCompleteFlow()">üöÄ Test Flujo Completo</button>
        <button class="button" onclick="clearResults()">üßπ Limpiar</button>
        
        <div id="results"></div>
    </div>

    <script src="main.js"></script>
    <script src="xgboost.js"></script>
    <script src="lightgbm.js"></script>
    <script src="neuralnet.js"></script>
    <script src="hybrid.js"></script>
    <script src="lstm.js"></script>
    <script src="lstm-nn.js"></script>
    <script src="lstm-lightgbm.js"></script>
    <script src="lstm-xgboost.js"></script>
    <script src="consensus.js"></script>
    <script src="events.js"></script>

    <script>
        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        function testUpdateFunctions() {
            clearResults();
            const resultsDiv = document.getElementById('results');
            
            let html = '<h2>üîç Test de Funciones de Actualizaci√≥n</h2>';
            
            const updateFunctions = [
                'updateXGBoostResults',
                'updateLightGBMResults', 
                'updateNeuralNetResults',
                'updateHybridResults',
                'updateLSTMResults',
                'updateLSTMNeuralNetworkResults',
                'updateLSTMLightGBMResults',
                'updateLSTMXGBoostResults',
                'updateConsensusResults'
            ];
            
            html += '<div class="test-box">';
            html += '<h3>üìã Verificaci√≥n de Disponibilidad</h3>';
            html += '<table border="1" style="width: 100%; border-collapse: collapse;">';
            html += '<tr><th>Funci√≥n</th><th>En window</th><th>En global</th><th>Estado</th></tr>';
            
            let availableCount = 0;
            
            updateFunctions.forEach(funcName => {
                const inWindow = typeof window[funcName] === 'function';
                let inGlobal = false;
                
                try {
                    inGlobal = typeof eval(funcName) === 'function';
                } catch (e) {
                    inGlobal = false;
                }
                
                const isAvailable = inWindow || inGlobal;
                if (isAvailable) availableCount++;
                
                const statusClass = isAvailable ? 'success' : 'error';
                const statusText = isAvailable ? '‚úÖ Disponible' : '‚ùå No encontrada';
                
                html += `<tr class="${statusClass}">`;
                html += `<td>${funcName}</td>`;
                html += `<td>${inWindow ? '‚úÖ' : '‚ùå'}</td>`;
                html += `<td>${inGlobal ? '‚úÖ' : '‚ùå'}</td>`;
                html += `<td>${statusText}</td>`;
                html += '</tr>';
            });
            
            html += '</table>';
            html += `<p><strong>Resumen:</strong> ${availableCount}/${updateFunctions.length} funciones disponibles</p>`;
            html += '</div>';
            
            // Test de la funci√≥n safeCallUpdateFunction
            html += '<div class="test-box">';
            html += '<h3>üõ°Ô∏è Test de safeCallUpdateFunction</h3>';
            
            if (typeof safeCallUpdateFunction === 'function') {
                html += '<p class="success">‚úÖ safeCallUpdateFunction est√° disponible</p>';
                
                // Crear datos de prueba
                const testResults = [
                    { date: '2024-01-01', actual: 45, predicted: 47 },
                    { date: '2024-01-02', actual: 67, predicted: 65 }
                ];
                
                // Test con funci√≥n existente
                try {
                    safeCallUpdateFunction('updateXGBoostResults', testResults, {});
                    html += '<p class="success">‚úÖ Llamada segura a updateXGBoostResults exitosa</p>';
                } catch (error) {
                    html += `<p class="error">‚ùå Error en llamada segura: ${error.message}</p>`;
                }
                
                // Test con funci√≥n inexistente
                try {
                    safeCallUpdateFunction('funcionInexistente', testResults, {});
                    html += '<p class="success">‚úÖ Manejo de funci√≥n inexistente exitoso</p>';
                } catch (error) {
                    html += `<p class="warning">‚ö†Ô∏è Error manejando funci√≥n inexistente: ${error.message}</p>`;
                }
                
            } else {
                html += '<p class="error">‚ùå safeCallUpdateFunction no est√° disponible</p>';
            }
            
            html += '</div>';
            
            resultsDiv.innerHTML = html;
        }

        async function testCompleteFlow() {
            clearResults();
            const resultsDiv = document.getElementById('results');
            
            let html = '<h2>üöÄ Test de Flujo Completo</h2>';
            
            try {
                html += '<div class="test-box">';
                html += '<h3>üîÑ Simulando Ejecuci√≥n de Modelos</h3>';
                
                // Crear datos de prueba
                const testData = [];
                for (let i = 1; i <= 10; i++) {
                    const date = new Date(2024, 0, i);
                    testData.push({
                        date: date.toISOString().split('T')[0],
                        DC: Math.floor(Math.random() * 40) + 40,
                        EXT: Math.floor(Math.random() * 40) + 40,
                        ULT2: Math.floor(Math.random() * 40) + 40,
                        PM2: Math.floor(Math.random() * 40) + 40,
                        C1C3: Math.floor(Math.random() * 40) + 40,
                        C2C4: Math.floor(Math.random() * 40) + 40
                    });
                }
                
                const wrappedData = { processedData: testData };
                const modelData = prepareDataForModels(wrappedData, 'DC', 5);
                
                html += `<p class="success">‚úÖ Datos preparados: ${modelData.trainData.length} entrenamiento, ${modelData.testData.length} prueba</p>`;
                
                // Test XGBoost con funci√≥n segura
                if (typeof window.runXGBoostModel === 'function') {
                    try {
                        const xgbResult = await window.runXGBoostModel(
                            modelData.trainData,
                            modelData.testData,
                            modelData.futureDates,
                            'DC'
                        );
                        
                        html += `<p class="success">‚úÖ XGBoost ejecutado: ${xgbResult.validation?.length || 0} validaciones</p>`;
                        
                        // Test actualizaci√≥n con funci√≥n segura
                        if (typeof safeCallUpdateFunction === 'function') {
                            safeCallUpdateFunction('updateXGBoostResults', xgbResult, modelData);
                            html += '<p class="success">‚úÖ Actualizaci√≥n XGBoost exitosa con funci√≥n segura</p>';
                        } else {
                            html += '<p class="error">‚ùå safeCallUpdateFunction no disponible</p>';
                        }
                        
                    } catch (error) {
                        html += `<p class="error">‚ùå Error en XGBoost: ${error.message}</p>`;
                    }
                } else {
                    html += '<p class="warning">‚ö†Ô∏è runXGBoostModel no disponible</p>';
                }
                
                // Test LightGBM
                if (typeof window.runLightGBMModel === 'function') {
                    try {
                        const lgbResult = await window.runLightGBMModel(
                            modelData.trainData,
                            modelData.testData,
                            modelData.futureDates,
                            'DC'
                        );
                        
                        html += `<p class="success">‚úÖ LightGBM ejecutado: ${lgbResult.length} resultados</p>`;
                        
                        safeCallUpdateFunction('updateLightGBMResults', lgbResult, modelData);
                        html += '<p class="success">‚úÖ Actualizaci√≥n LightGBM exitosa</p>';
                        
                    } catch (error) {
                        html += `<p class="error">‚ùå Error en LightGBM: ${error.message}</p>`;
                    }
                } else {
                    html += '<p class="warning">‚ö†Ô∏è runLightGBMModel no disponible</p>';
                }
                
                html += '</div>';
                
                // Test de verificaci√≥n de funciones
                html += '<div class="test-box">';
                html += '<h3>üîç Verificaci√≥n Post-Ejecuci√≥n</h3>';
                
                if (typeof ensureModelFunctionsLoaded === 'function') {
                    try {
                        await ensureModelFunctionsLoaded();
                        html += '<p class="success">‚úÖ Verificaci√≥n de funciones completada</p>';
                    } catch (error) {
                        html += `<p class="error">‚ùå Error en verificaci√≥n: ${error.message}</p>`;
                    }
                } else {
                    html += '<p class="error">‚ùå ensureModelFunctionsLoaded no disponible</p>';
                }
                
                html += '</div>';
                
                // Logs de consola
                html += '<div class="test-box">';
                html += '<h3>üìù Informaci√≥n de Depuraci√≥n</h3>';
                html += '<pre id="debug-info">Preparando informaci√≥n de debug...</pre>';
                html += '</div>';
                
                // Recopilar informaci√≥n de debug
                setTimeout(() => {
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        let debugText = '=== ESTADO DEL SISTEMA ===\n';
                        debugText += `Timestamp: ${new Date().toLocaleString()}\n\n`;
                        
                        debugText += '=== FUNCIONES DISPONIBLES ===\n';
                        const functions = [
                            'runXGBoostModel', 'updateXGBoostResults',
                            'runLightGBMModel', 'updateLightGBMResults',
                            'safeCallUpdateFunction', 'ensureModelFunctionsLoaded'
                        ];
                        
                        functions.forEach(func => {
                            const available = typeof window[func] === 'function';
                            debugText += `${func}: ${available ? '‚úÖ' : '‚ùå'}\n`;
                        });
                        
                        debugText += '\n=== DATOS DE PRUEBA ===\n';
                        debugText += `Test data length: ${testData.length}\n`;
                        debugText += `Model data train: ${modelData.trainData.length}\n`;
                        debugText += `Model data test: ${modelData.testData.length}\n`;
                        
                        debugInfo.textContent = debugText;
                    }
                }, 500);
                
            } catch (error) {
                html += `<div class="test-box"><p class="error">‚ùå Error cr√≠tico: ${error.message}</p></div>`;
                console.error('Error en test completo:', error);
            }
            
            resultsDiv.innerHTML = html;
        }

        // Auto-ejecutar tests al cargar
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(testUpdateFunctions, 1000);
        });
    </script>
</body>
</html>
